
void loadModelFile(std::string package_name, std::string filename, std::string& file_content)
{
  std::filesystem::path res_path(ament_index_cpp::get_package_share_directory(package_name));
  std::string xml_string;
  std::fstream xml_file((res_path / filename).string().c_str(), std::fstream::in);
  while (xml_file.good())
  {
    std::string line;
    std::getline(xml_file, line);
    xml_string += (line + "\n");
  }
  xml_file.close();
  file_content = xml_string;
}

bool inputKinematicsYAML(const std::filesystem::path& file_path)
{
  // Load file
  std::ifstream input_stream(file_path);
  if (!input_stream.good())
  {
    return false;
  }

  // Begin parsing
  try
  {
    YAML::Node doc = YAML::Load(input_stream);

    // Loop through all groups
    for (YAML::const_iterator group_it = doc.begin(); group_it != doc.end(); ++group_it)
    {
      const std::string& group_name = group_it->first.as<std::string>();
      const YAML::Node& group = group_it->second;

    }

    return true;
  }
  catch (YAML::ParserException& e)  // Catch errors
  {
    return false;
  }
}

void parseNode(YAML::Node node) {
  if (node.IsMap()) {
    for (YAML::iterator it = node.begin(); it != node.end(); ++it) {
      parseNode(it->second);
    }
  }
  else if (node.IsSequence()) {
    for (YAML::iterator it = node.begin(); it != node.end(); ++it) {
      parseNode(*it);
    }
  }
  else if (node.IsScalar()) {
    // Perform modifications here.
    std::cout << node;
  }
}